import ScriptAnalyzer from "../../../utils/scriptAnalyzer.js";

export class UserscriptHandler {
  constructor(editor) {
    this.editor = editor;
  }

  toSingleLine(value) {
    return (value || "")
      .replace(/[`*_#>]/g, "")
      .replace(/\r?\n+/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  toConciseSentence(value, fallback = "Generated by CodeTweak AI.") {
    const cleaned = this.toSingleLine(value)
      .replace(/^\s*(?:this\s+script\s*:?)\s*/i, "")
      .replace(/^\s*(?:script\s+name\s*:?)\s*/i, "")
      .trim();

    if (!cleaned) return fallback;

    const sentenceMatch = cleaned.match(/^(.{1,180}?[.!?])(?:\s|$)/);
    let sentence = sentenceMatch ? sentenceMatch[1] : cleaned;

    if (sentence.length > 160) {
      sentence = `${sentence.slice(0, 157).trimEnd()}.`;
    } else if (!/[.!?]$/.test(sentence)) {
      sentence = `${sentence}.`;
    }

    return sentence;
  }

  toScriptTitle(value, fallback) {
    const cleaned = this.toSingleLine(value)
      .replace(/^script name:\s*/i, "")
      .replace(/^["']|["']$/g, "")
      .trim();

    if (!cleaned || /^generated script$/i.test(cleaned)) {
      return fallback;
    }

    if (cleaned.length > 80) {
      return cleaned.slice(0, 80).trimEnd();
    }

    return cleaned;
  }

  normalizeGeneratedCode(input) {
    let code = typeof input === "string" ? input : JSON.stringify(input);
    const fencedMatch = code.match(/```(?:javascript|js)?\s*([\s\S]*?)```/i);
    if (fencedMatch?.[1]) {
      code = fencedMatch[1].trim();
    }

    code = code
      .replace(/^\s*(?:\/\/\s*)?Script Name:\s*.+$/gim, "")
      .replace(
        /^\s*(?:Key points|Notes|Explanation|What this does)\s*:[\s\S]*?(?=\n\s*(?:\/\/\s*==UserScript==|\(\s*function|const\s+|let\s+|var\s+|function\s+|GM_\w+\s*\(|document\.|window\.))/i,
        ""
      )
      .trim();

    code = code
      .replace(
        /^\s*(?:\/\/\s*)?==UserScript==[\s\S]*?(?:\/\/\s*)?==\/UserScript==\s*/i,
        ""
      )
      .trim();

    const iifeMatch = code.match(
      /(\(\s*function\s*\(\)\s*\{[\s\S]*?\}\)\(\);?|\(\s*\(\)\s*=>\s*\{[\s\S]*?\}\)\(\);?)/m
    );
    if (iifeMatch?.[1]) {
      return iifeMatch[1].trim();
    }

    return code;
  }

  extractCleanCodeAndExplanation(inputCode, fallbackExplanation = "") {
    let code = this.normalizeGeneratedCode(inputCode)
      .replace(
        /(?:\/\/\s*)?==UserScript==[\s\S]*?(?:\/\/\s*)?==\/UserScript==\n*/gi,
        ""
      )
      .trim();

    let extractedExplanation = null;
    const commentMatch = code.match(/^\s*\/\/\s*(.*)\r?\n/);
    if (commentMatch && commentMatch[1]) {
      extractedExplanation = commentMatch[1].trim();
      code = code.substring(commentMatch[0].length).trim();
    }

    return {
      code,
      explanation: extractedExplanation || fallbackExplanation || "",
    };
  }

  buildFinalScript(cleanCode, metadata) {
    const wrappedCode = this.wrapInIIFE(cleanCode);
    return ScriptAnalyzer.rebuildWithEnhancedMetadata(wrappedCode, metadata);
  }

  async getScriptContent(scriptName) {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        { action: "getScriptContent", scriptName },
        (response) => {
          if (chrome.runtime.lastError) {
            return reject(new Error(chrome.runtime.lastError.message));
          }
          if (response.error) {
            return reject(new Error(response.error));
          }
          resolve(response.code);
        }
      );
    });
  }

  async getAllScripts() {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage({ action: "getAllScripts" }, (response) => {
        if (chrome.runtime.lastError) {
          return reject(new Error(chrome.runtime.lastError.message));
        }
        if (response.error) {
          return reject(new Error(response.error));
        }
        resolve(response.scripts);
      });
    });
  }

  async createUserscript(code, name = null, explanation = null) {
    try {
      const [tab] = await chrome.tabs.query({
        active: true,
        currentWindow: true,
      });
      const url = new URL(tab.url);

      const prepared = this.extractCleanCodeAndExplanation(code, explanation);
      const scriptCode = prepared.code;
      const userPrompt = this.editor.eventHandler?.lastUserPrompt || "";

      const fallbackTitle =
        ScriptAnalyzer.generateScriptName(url.hostname, userPrompt) ||
        "AI Generated Script";
      const scriptName = this.toScriptTitle(name, fallbackTitle);

      const descriptionSource = prepared.explanation || userPrompt || "";
      const description = this.toConciseSentence(
        descriptionSource,
        `Modifies ${url.hostname} as requested.`
      );

      const detectedApis = ScriptAnalyzer.detectGMApiUsage(scriptCode);
      const suggestedRunAt = ScriptAnalyzer.suggestRunAt(scriptCode);

      // Build metadata
      const metadata = {
        name: scriptName,
        namespace: "https://codetweak.local",
        version: "1.0.0",
        description: description,
        author: "CodeTweak AI",
        matches: [`${url.origin}/*`],
        gmApis: detectedApis,
        runAt: suggestedRunAt,
      };

      const finalScript = this.buildFinalScript(scriptCode, metadata);

      chrome.runtime.sendMessage(
        {
          action: "createScriptFromAI",
          script: finalScript,
          url: tab.url,
        },
        (response) => {
          if (response.error) {
            console.error("Error creating script:", response.error);
            this.editor.chatManager.addMessage(
              "assistant",
              `Error creating script: ${response.error}`,
              { type: "text", error: true }
            );
            return;
          }

          this.editor.chatManager.addMessage(
            "assistant",
            `✓ Script "${scriptName}" created successfully!`,
            { type: "text" }
          );
          this.editor.setCurrentScript(response.script);
        }
      );
    } catch (error) {
      console.error("Error creating userscript:", error);
      this.editor.chatManager.addMessage(
        "assistant",
        `Error creating script: ${error.message}`,
        { type: "text", error: true }
      );
    }
  }

  async updateUserscript(
    scriptName,
    newCode,
    newName = null,
    explanation = null
  ) {
    try {
      const { scripts = [] } = await chrome.storage.local.get("scripts");
      const scriptToUpdate = scripts.find((s) => s.name === scriptName);

      if (!scriptToUpdate) {
        throw new Error(`Script "${scriptName}" not found for update.`);
      }

      const metadata = ScriptAnalyzer.extractMetadata(scriptToUpdate.code);
      metadata.version = ScriptAnalyzer.incrementVersion(metadata.version);
      if (newName && newName !== scriptName && newName !== "Generated Script") {
        const fallbackTitle =
          ScriptAnalyzer.generateScriptName("", this.editor.eventHandler?.lastUserPrompt || "") ||
          scriptName;
        metadata.name = this.toScriptTitle(newName, fallbackTitle);
      }

      const prepared = this.extractCleanCodeAndExplanation(newCode, explanation);
      const cleanCode = prepared.code;

      if (prepared.explanation) {
        metadata.description = this.toConciseSentence(
          prepared.explanation,
          metadata.description || "Generated by CodeTweak AI."
        );
      }

      const detectedApis = ScriptAnalyzer.detectGMApiUsage(cleanCode);
      const suggestedRunAt = ScriptAnalyzer.suggestRunAt(cleanCode);

      metadata.gmApis = {
        ...metadata.gmApis,
        ...detectedApis,
      };

      metadata.runAt = suggestedRunAt;
      const finalScript = this.buildFinalScript(cleanCode, metadata);

      chrome.runtime.sendMessage(
        {
          action: "updateScript",
          scriptId: scriptToUpdate.id,
          code: finalScript,
        },
        (response) => {
          if (chrome.runtime.lastError || response?.error) {
            const errorMsg =
              chrome.runtime.lastError?.message || response.error;
            console.error("Error updating script in background:", errorMsg);
            this.editor.chatManager.addMessage(
              "assistant",
              `Error updating script: ${errorMsg}`,
              { type: "text", error: true }
            );
          } else {
            const displayName = metadata.name || scriptName;
            this.editor.chatManager.addMessage(
              "assistant",
              `✓ Script "${displayName}" updated successfully!`,
              { type: "text" }
            );

            if (newName && newName !== scriptName) {
              this.editor.setCurrentScript({
                ...scriptToUpdate,
                name: newName,
                code: finalScript,
              });
            }
          }
        }
      );
    } catch (error) {
      console.error("Error updating userscript:", error);
      this.editor.chatManager.addMessage(
        "assistant",
        `Error updating script: ${error.message}`,
        { type: "text", error: true }
      );
    }
  }

  wrapInIIFE(code) {
    const isWrapped =
      /^\s*\(\s*function\s*\(/.test(code) || 
      /^\s*\(function\s*\(/.test(code) ||
      /^\s*\(\s*\(\s*\)\s*=>\s*{/.test(code); // Arrow function IIFE

    if (isWrapped) {
      return code;
    }

    const lines = code.split("\n");
    const indentedLines = lines.map((line) => "    " + line);

    return `(function() {
    'use strict';
    
${indentedLines.join("\n")}
})();`;
  }
}
